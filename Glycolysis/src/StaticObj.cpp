/*
 * StaticObj.cpp
 *
 *  Created on: Jan 6, 2014
 *      Author: peter
 */



#include <GL/glew.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <SDL2/SDL.h>
#include "../inc/StaticObj.h"
#include "../inc/objloader.hpp"
#include "../inc/vboindexer.hpp"
#include "../inc/texture.hpp"
#include "../inc/shader.hpp"
#include "../inc/ResObj.h"
#include "../inc/shader.hpp"

StaticObj::StaticObj(int id,
		glm::vec3 scale,
		ObjectType objType,
		GLuint texture,
		glm::vec3 trans,
		LPWatch* watch,
		ResObj& resObj,
		const View& view,
		LPUniform lpUniform) :
    LPObject (id, trans, scale, watch),
			resObj(resObj),
			view(view),
			lpUniform(lpUniform)
{
	currentObj = objType;
	this->objType = objType;
	Texture = texture;
	this->scale = scale;
	glActiveTexture(GL_TEXTURE1);

	ModelMatrix = glm::mat4(1.0f);
	ModelMatrix = glm::scale(ModelMatrix,scale);
	ModelMatrix = glm::translate(ModelMatrix,trans);

	glm::mat4 MVP;
//  Shader shader("shaders/text.v.glsl", "shaders/text.f.glsl");
//  programID2 = shader.getProgramId();
//	text_program_id = programID2;
//	MatrixID2 = glGetUniformLocation(programID2, "MVP");
//	ViewMatrixID2 = glGetUniformLocation(programID2, "V");
//	ModelMatrixID2 = glGetUniformLocation(programID2, "M");
//	LightID2 = glGetUniformLocation(programID2, "LightPosition_worldspace");
//	TextureID2  = glGetUniformLocation(programID2, "myTextureSampler");

	setRotationMatrix_X(0);

  m_startTime = GetCurrentTimeMillis();
}

void StaticObj::draw() {
  for (buffer* buf : resObj.getMesh(currentObj)) {
    internalDraw(buf);
  }
}

void StaticObj::draw(ObjectType obj) {
  tmpObjectType = obj;
  for (buffer* buf: resObj.getMesh(obj)) {
    internalDraw(obj, buf);
  }
}

void StaticObj::internalDraw(ObjectType obj, buffer* buf) {
//  TRACE_ERROR("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX InternalDraw1");
  glUseProgram(lpUniform.programID);
  SDL_LogDebug (SDL_LOG_CATEGORY_CUSTOM,"programID = %d, glGetError()=%d\n", lpUniform.programID, glGetError());
//  fprintf(stderr, "programID = %d, glGetError()=%d\n", lpUniform.programID, glGetError());
	glm::mat4 ModelMatrix = glm::mat4(1.0);
//  ModelMatrix = glm::translate(ModelMatrix, getTrans() + buf->trans) * getRotationMatrix() * glm::scale(ModelMatrix, scale);
  ModelMatrix = glm::translate(ModelMatrix, getTrans()) * getRotationMatrix() * glm::scale(ModelMatrix, scale);
	MVP = view.getProjectionMatrix() * view.getViewMatrix() * ModelMatrix;

	// Send our transformation to the currently bound shader,
	// in the "MVP" uniform
  glUniformMatrix4fv(lpUniform.MatrixID, 1, GL_FALSE, &MVP[0][0]);
  glUniformMatrix4fv(lpUniform.ModelMatrixID, 1, GL_FALSE, &ModelMatrix[0][0]);
  glUniformMatrix4fv(lpUniform.ViewMatrixID, 1, GL_FALSE, &(view.getViewMatrix())[0][0]);

  useColorID = glGetUniformLocation(lpUniform.programID, "useColor");
  colorID = glGetUniformLocation(lpUniform.programID, "objColor");
  lightPowerID = glGetUniformLocation(lpUniform.programID, "LightPower");
	glUniform1f(lightPowerID, lightPower);
  GLfloat isAnimationID;
  isAnimationID = glGetUniformLocation(lpUniform.programID, "isAnimation");

  SDL_LogDebug (SDL_LOG_CATEGORY_CUSTOM, "useColorID = %d, colorID = %d, lightPowerID = %d\n", useColorID, colorID, lightPowerID);
//  fprintf(stderr, "useColorID = %d, colorID = %d, lightPowerID = %d\n", useColorID, colorID, lightPowerID);

//std::cout << "StaticObj:: Error internalDraw(obj, buf)" << std::endl;
  if (isAnimationID == -1) {

    switch (glGetError())
    {
    case GL_INVALID_VALUE:
     SDL_LogError (SDL_LOG_CATEGORY_CUSTOM, "Error: GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.\n");
//      fprintf(stderr, "Error: GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.\n");
      break;
    case GL_INVALID_OPERATION:
     SDL_LogError (SDL_LOG_CATEGORY_CUSTOM, "GL_INVALID_OPERATION is generated if program is not a program object.\n");
//      fprintf(stderr, "GL_INVALID_OPERATION is generated if program is not a program object.\n");
      break;
    default:
     SDL_LogError(SDL_LOG_CATEGORY_CUSTOM, "Error: Unknown Error: %d\n", glGetError());
//      fprintf(stderr, "Error: Unknown Error: %d\n", glGetError());
    }
  }

  if (isAnimationID == 999) {
    SDL_LogError(SDL_LOG_CATEGORY_CUSTOM, "isAnimationID was never retrieved\n");
//    fprintf(stderr, "Error: isAnimationID was never retrieved\n");
  }
  else {
    SDL_LogDebug(SDL_LOG_CATEGORY_CUSTOM, "isAnimationID = %f\n", isAnimationID);
//    fprintf(stderr, "isAnimationID = %f\n", isAnimationID);
  }
    if (resObj.meshArray[obj].mesh[0]->m_NumAnimations > 0) {

    glUniform1i(isAnimationID, 1);
  }
  else {
    glUniform1i(isAnimationID, 0);
  }

  //glUniform1i(isAnimationID, 0);
  GLint isAnimation;
  glGetUniformiv(lpUniform.programID, isAnimationID, &isAnimation);
  SDL_LogDebug(SDL_LOG_CATEGORY_CUSTOM, "isAnimation = %d\n", isAnimation);
//  fprintf(stderr, "isAnimation = %d\n", isAnimation);
	//setObjColor(glm::vec3(1.0f, 1.0f, 0.0f));

	//	if (useColorID == 999)
	//	{
	//	  fprintf(stderr, "Error: colorID was never retrieved");
	//	}

	//	if (obj == arrow_rectangle_down_single1 || arrow_rectangle_down_up)
	{
		glUniform1f(useColorID, getUseColor());
    if (getId() > 26000 && getId() < 26019) {
      glUniform3f(colorID, getObjColor().x, getObjColor().y, getObjColor().z);
    }
    else {
      glUniform3f(colorID, buf->meshColor[0], buf->meshColor[1], buf->meshColor[2]);
    }

//		glUniform3f(colorID, buf->meshColor[0], buf->meshColor[1], buf->meshColor[2]);
//		glUniform3f(colorID, buf->meshColor[0], buf->meshColor[1], buf->meshColor[2]);
		//    std::cout << "color: (" << buf->meshColor[0] << ", " << buf->meshColor[1] << ", " << buf->meshColor[2] << ")" << std::endl;
	}
	//	else
	//	{
	//	  glUniform1f(useColorID, 0.0);
	//	}

	//glm::vec3 lightPos = glm::vec3(0.0f,20.0f,45.0f); is set in header file
//	glUniform3f(LightID, getLightPos().x, getLightPos().y, getLightPos().z);

//  if (getOrientation ().y != 0.0f)
//  {
//    glUniform3f (LightID, -45.0f, 20.0f, 0.0f);
//  }
//  else
//  {
//    glUniform3f (LightID, 0.0f, 20.0f, 45.0f);
//  }

	// Bind our texture in Texture Unit 1
	glActiveTexture(GL_TEXTURE1);

	glBindTexture(GL_TEXTURE_2D, this->Texture);
	// Set our "myTextureSampler" sampler to user Texture Unit 1
  glUniform1i(lpUniform.TextureID, GL_TEXTURE1);

  // 1st attribute buffer : vertices
	glEnableVertexAttribArray(0);
  //	glBindBuffer(GL_ARRAY_BUFFER, resObj->getVertexbuffer(obj));
  glBindBuffer(GL_ARRAY_BUFFER, buf->vertices);
	glVertexAttribPointer(
			0,                  // attribute
			3,                  // size
			GL_FLOAT,           // type
			GL_FALSE,           // normalized?
			0,                  // stride
			(void*)0            // array buffer offset
			);

	// 2nd attribute buffer : UVs
	glEnableVertexAttribArray(1);
  //	glBindBuffer(GL_ARRAY_BUFFER, resObj->getUvbuffer(obj));
  glBindBuffer(GL_ARRAY_BUFFER, buf->uvs);
	glVertexAttribPointer(
			1,                                // attribute
			2,                                // size
			GL_FLOAT,                         // type
			GL_FALSE,                         // normalized?
			0,                                // stride
			(GLvoid*)0                         // array buffer offset
			);


	// 3rd attribute buffer : normals
	glEnableVertexAttribArray(2);
  //	glBindBuffer(GL_ARRAY_BUFFER, resObj->getNormalbuffer(obj));
  glBindBuffer(GL_ARRAY_BUFFER, buf->normals);
	glVertexAttribPointer(
			2,                                // attribute
			3,                                // size
			GL_FLOAT,                         // type
			GL_FALSE,                         // normalized?
			0,                                // stride
			(GLvoid*)0                          // array buffer offset
			);

  // 4th attribute buffer : bones id
  glEnableVertexAttribArray(3);
  glBindBuffer(GL_ARRAY_BUFFER, buf->bones);
  glVertexAttribIPointer(3,                                     // attribute
      4,                                     // size
      GL_INT,                                // type
      sizeof(VertexBoneData), (const GLvoid*) 0                            // array buffer offset
      );

  // 5th attribute buffer : bones weight
  glEnableVertexAttribArray(4);
  glVertexAttribPointer(4,                             // attribute
      4,                                               // size
      GL_FLOAT,                                        // type
      GL_FALSE, sizeof(VertexBoneData), (const GLvoid*) 16   // array buffer offset
      );

  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, buf->indices);

	// Draw the triangles !
	//	glDrawArrays(GL_TRIANGLES, 0, resObj->getVertices(obj).size());
//	glDrawArrays(GL_TRIANGLES, 0, buf->sizeOfVertices);
  glDrawElements(GL_TRIANGLES, buf->sizeOfIndices, GL_UNSIGNED_INT, 0);

	glDisableVertexAttribArray(0);
	glDisableVertexAttribArray(1);
	glDisableVertexAttribArray(2);
  glDisableVertexAttribArray(3);
  glDisableVertexAttribArray(4);
}



void StaticObj::internalDraw(buffer* buf) {
// PETER: BIG Note: Animation is set to 0 here, i.e this one cannot draw animated objects

//  TRACE_ERROR(" ----------------------------------------------------------------------- InternalDraw2");
  glUseProgram(lpUniform.programID);
	glm::mat4 ModelMatrix = glm::mat4(1.0);
	ModelMatrix = glm::translate(ModelMatrix,getTrans()) * getRotationMatrix() * glm::scale(ModelMatrix,scale);
	MVP = view.getProjectionMatrix() * view.getViewMatrix() * ModelMatrix;

	// Send our transformation to the currently bound shader,
	// in the "MVP" uniform
  glUniformMatrix4fv(lpUniform.MatrixID, 1, GL_FALSE, &MVP[0][0]);
  glUniformMatrix4fv(lpUniform.ModelMatrixID, 1, GL_FALSE, &ModelMatrix[0][0]);
  glUniformMatrix4fv(lpUniform.ViewMatrixID, 1, GL_FALSE, &(view.getViewMatrix())[0][0]);
	//glm::vec3 lightPos = glm::vec3(30.0f,40.0f,30.0f);

  useColorID = glGetUniformLocation(lpUniform.programID, "useColor");
  colorID = glGetUniformLocation(lpUniform.programID, "objColor");
  lightPowerID = glGetUniformLocation(lpUniform.programID, "LightPower");
  glUniform1f(lightPowerID, lightPower);
//  std::cout << "StaticObj:: Error internalDraw(buf)" << std::endl;
  if (colorID == 999)
    {
      SDL_LogError(SDL_LOG_CATEGORY_CUSTOM, "Error: colorID was never retrieved");
//      fprintf(stderr, "Error: colorID was never retrieved");
    }

  //  if (obj == arrow_rectangle_down_single1 || arrow_rectangle_down_up)
    glUniform1f(useColorID, getUseColor());
  if (getId() > 26000 && getId() < 26019) {
    glUniform3f(colorID, getObjColor().x, getObjColor().y, getObjColor().z);
  }
  else {
    glUniform3f(colorID, buf->meshColor[0], buf->meshColor[1], buf->meshColor[2]);
  }

  glUniform3f(lpUniform.LightID, getLightPos().x, getLightPos().y, getLightPos().z);
  GLuint isAnimationID = glGetUniformLocation(lpUniform.programID, "isAnimation");
  glUniform1i(isAnimationID, 0);

	// Bind our texture in Texture Unit 1
  glActiveTexture (GL_TEXTURE2);
	glBindTexture(GL_TEXTURE_2D, this->Texture);
//	 Set our "myTextureSampler" sampler to user Texture Unit 1
  glUniform1i(lpUniform.TextureID, 2);

	// 1rst attribute buffer : vertices
	glEnableVertexAttribArray(0);
//	glBindBuffer(GL_ARRAY_BUFFER, resObj->getVertexbuffer(currentObj));
  glBindBuffer(GL_ARRAY_BUFFER, buf->vertices);
	glVertexAttribPointer(
			0,                  // attribute
			3,                  // size
			GL_FLOAT,           // type
			GL_FALSE,           // normalized?
			0,                  // stride
			(void*)0            // array buffer offset
	);

	// 2nd attribute buffer : UVs
	glEnableVertexAttribArray(1);
  glBindBuffer(GL_ARRAY_BUFFER, buf->uvs);
	glVertexAttribPointer(
			1,                                // attribute
			2,                                // size
			GL_FLOAT,                         // type
			GL_FALSE,                         // normalized?
			0,                                // stride
			(void*)0                          // array buffer offset
	);

	// 3rd attribute buffer : normals
	glEnableVertexAttribArray(2);
  glBindBuffer(GL_ARRAY_BUFFER, buf->normals);
	glVertexAttribPointer(
			2,                                // attribute
			3,                                // size
			GL_FLOAT,                         // type
			GL_FALSE,                         // normalized?
			0,                                // stride
			(void*)0                          // array buffer offset
	);

  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, buf->indices);


	// Draw the triangles !
//	glDrawArrays(GL_TRIANGLES, 0, buf->sizeOfVertices);
  glDrawElements(GL_TRIANGLES, buf->sizeOfIndices, GL_UNSIGNED_INT, 0);

	glDisableVertexAttribArray(0);
	glDisableVertexAttribArray(1);
	glDisableVertexAttribArray(2);
}

StaticObj::~StaticObj() {

}

float StaticObj::getHorizontalAngle() const {
	return horizontalAngle;
}

void StaticObj::setHorizontalAngle(float horizontalAngle) {
	this->horizontalAngle = horizontalAngle;
}

float StaticObj::getVerticalAngle() const {
	return verticalAngle;
}

void StaticObj::setVerticalAngle(float verticalAngle) {
	this->verticalAngle = verticalAngle;
}

bool StaticObj::isStatic() {
	return true;
}

void StaticObj::createId() {

}

void StaticObj::move(bool flag) {

}

void
StaticObj::move (std::vector<std::pair<int, int>> collisionDetected, glm::vec3 normal) {
  TRACE_INFO("ENTER StaticObj::move for object = %d, id = %d, with Trans = (%f,%f,%f)", currentObj, getId(), getTrans().x, getTrans().y, getTrans().z);
  if (resObj.meshArray[currentObj].mesh[0]->m_NumAnimations > 0) {
    float RunningTime = (float) ((double) GetCurrentTimeMillis() - (double) m_startTime) / 1000.0f;
    animTime = currAnimTime;
    currAnimTime = resObj.meshArray[currentObj].BoneTransform(RunningTime, Transforms);
    for (GLuint i = 0; i < Transforms.size(); i++) {
      SetBoneTransform(i, Transforms[i]);
    }
  }
}

void StaticObj::SetBoneTransform(GLuint Index, glm::mat4& Transform)
{
  TRACE_INFO("Scene::SetBoneTransform Input parameters : index=%d, MAX_BONES=%d", Index, MAX_BONES);
  assert(Index < MAX_BONES);
  const GLfloat m[4][4] = { { Transform[0][0], Transform[0][1], Transform[0][2], Transform[0][3] }, { Transform[1][0], Transform[1][1], Transform[1][2], Transform[1][3] }, { Transform[2][0], Transform[2][1], Transform[2][2], Transform[2][3] }, {
      Transform[3][0], Transform[3][1], Transform[3][2], Transform[3][3] } };
  glUniformMatrix4fv(lpUniform.BoneLocationID[Index], 1, GL_TRUE, (const GLfloat*) m);
}


